{"content":"## UseEffect\r\n\r\n> *Effect Hook* 可以让你在函数组件中执行副作用操作\r\n>\r\n> **提示**：\r\n>\r\n> 如果你熟悉 React class 的生命周期函数，你可以把 `useEffect` Hook 看做 `componentDidMount`，`componentDidUpdate` 和 `componentWillUnmount` 这三个函数的组合。\r\n\r\n### 执行时机\r\n\r\n> 与 `componentDidMount`、`componentDidUpdate` 不同的是，传给 `useEffect` 的函数会在浏览器完成布局与绘制**之后**，在一个延迟事件中被调用。\r\n>\r\n> 然而，并非所有 effect 都可以被延迟执行。对于需要同步执行的`hooks`我们需要使用`useLayoutEffect`。\r\n>\r\n> `Effect`会保证在任何新的渲染前执行，在开始执行新的`Effect CallBack`前，总会清除上一轮渲染的`Effect`。\r\n\r\n1. 默认情况，在第一次渲染之后*和*每次更新之后都会执行\r\n\r\n   ```react\r\n   const Effect: React.FC = () => {\r\n     const [value, setValue] = React.useState('');\r\n     React.useEffect(() => {\r\n       document.title = value;\r\n       console.log('value is ', value);\r\n     });\r\n     return (\r\n       <div>\r\n         <h2>Effect</h2>\r\n         <input\r\n           value={value}\r\n           onChange={(e) => setValue(e.target.value)}\r\n           placeholder=\"document.title\" />\r\n       </div>\r\n     );\r\n   };\r\n   ```\r\n\r\n2. 仅仅在`Dom`第一次渲染和每次`value`变化后执行\r\n\r\n   ```react\r\n   React.useEffect(() => {\r\n       console.log('[dep value] value is ', value);\r\n     }, [value]);\r\n   ```\r\n\r\n3. 仅仅在`Dom`第一次渲染执行\r\n\r\n   ```react\r\n   React.useEffect(() => {\r\n       console.log('[first render] value is ', value);\r\n     }, []);\r\n   ```\r\n\r\n### 传入依赖的比较规则\r\n\r\n### `Object.is()`\r\n\r\n> 用于判断两个值是否为同一个值\r\n\r\n如果满足以下条件则两个值相等：\r\n\r\n- 都是 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\r\n- 都是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)\r\n- 都是 `true` 或 `false`\r\n- 都是相同长度的字符串且相同字符按相同顺序排列\r\n- 都是相同对象（意味着每个对象有同一个引用）\r\n- 都是数字且\r\n  - 都是 `+0`\r\n  - 都是 `-0`\r\n  - 都是 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)\r\n  - 或都是非零而且非 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 且为同一个值\r\n\r\n与[`==` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators) 运算*不同。* `==` 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 `\"\" == false` 判断为 `true`), 而 `Object.is`不会强制转换两边的值。\r\n\r\n与[`===` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators) 运算也不相同。 `===` 运算符 (也包括 `==` 运算符) 将数字 `-0` 和 `+0` 视为相等 ，而将[`Number.NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN) 与[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)视为不相等.\r\n\r\n```js\r\n// polyfill Object.is\r\nif (!Object.is) {\r\n    Object.is = function(x, y) {\r\n        if (x === y) {\r\n            return x !== 0 || 1/x === 1/y;\r\n        } else {\r\n            return x !== x && y !== y;\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n","title":"[hooks]--useEffect"}
