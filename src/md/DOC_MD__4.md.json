{"content":"# React Router\r\n\r\n> 从`React Router`源码来一步步理解\r\n>\r\n> 源码一共有四个大的内容板块：\r\n>\r\n> - `React Router`：声明式的路由，提供核心的路由功能。不能单独使用，需要配合`React Router Dom`和`React Router Native`使用\r\n> - `React Router Dom`：浏览器应用使用\r\n> - `React Router Native`：`React Native`使用（**我们在这里不深入探讨它**）\r\n>\r\n> 我们以`Browser Router`为例，一步一步来深入理解\r\n\r\n## history\r\n\r\n在了解`React Router`之前，我们先来了解下他们的核心依赖`history`。\r\n\r\n这是一个由[Remix](https://github.com/remix-run)（`React Router`开发团队）开发的`npm`包，其中包含了对于浏览器和其他环境中运行的`JavaScript`程序提供历史记录和原生的导航操作。\r\n\r\n同样，他也支持`browser history`、`hash history`、`memory history`（虽然现在的`React Router`以及不推荐使用）三种方式。\r\n\r\n当然了，在这里我们只关心我们用到的API，如果有感兴趣的同学可以前往[history](https://github.com/remix-run/history/blob/dev/docs/getting-started.md)去深入了解。\r\n\r\n1. `hisotry.listen`：监听当前的`location`的变化并在变化发生时调用给定的回调函数。\r\n\r\n2. `history.action`：当前（最近）的历史栈的修改操作，这个属性会随着当前的`location`的变化而变化\r\n\r\n3. `history.location`：当前的`location`，同样也是可变的\r\n\r\n4. `createPath`：创建`Route Path`\r\n\r\n5. `createBrowserHistory`：返回一个支持使用`HTML 5 history`进行`pushState`、`replaceState`以及`popState`事件的`BrowserHistory`实例。传入的`window`是当前需要展示视图默认所在的`document`\r\n\r\n   ```react\r\n   const PopStateEventType = 'popstate';\r\n   \r\n   function createPath({\r\n     pathname = '/',\r\n     search = '',\r\n     hash = ''\r\n   }: Partial<Path>) {\r\n     if (search && search !== '?')\r\n       pathname += search.charAt(0) === '?' ? search : '?' + search;\r\n     if (hash && hash !== '#')\r\n       pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\r\n     return pathname;\r\n   }\r\n   \r\n   //返回events队列（支持length、push、call方法）\r\n   function createEvents<F extends Function>(): Events<F> {\r\n     ……\r\n   }\r\n   \r\n   \r\n   function createBrowserHistory(\r\n     options: BrowserHistoryOptions = {}\r\n   ): BrowserHistory {\r\n     let { window = document.defaultView! } = options;\r\n     let globalHistory = window.history;\r\n   \r\n     // 返回当前的栈index和对应的window.location\r\n     function getIndexAndLocation(): [number, Location] {\r\n       ……\r\n     }\r\n   \r\n     let blockedPopTx: Transition | null = null;\r\n     function handlePop() {\r\n       ……\r\n     }\r\n   \r\n    //监听popState事件\r\n     window.addEventListener(PopStateEventType, handlePop);\r\n   \r\n     let action = Action.Pop;\r\n     let [index, location] = getIndexAndLocation();\r\n     let listeners = createEvents<Listener>();\r\n     ……\r\n   \r\n     //返回 默认第一个 路由\r\n     if (index == null) {\r\n       index = 0;\r\n       globalHistory.replaceState({ ...globalHistory.state, idx: index }, '');\r\n     }\r\n   \r\n     // 创建react router 的path\r\n     function createHref(to: To) {\r\n       return typeof to === 'string' ? to : createPath(to);\r\n     }\r\n   \r\n     // 获取跳转的location\r\n     // state默认为null是因为`window.history.state`也是如此\r\n     function getNextLocation(to: To, state: any = null): Location {\r\n       ……\r\n     }\r\n   \r\n   \t……\r\n   \r\n     let history: BrowserHistory = {\r\n       get action() {\r\n         return action;\r\n       },\r\n       get location() {\r\n         return location;\r\n       },\r\n   \t……\r\n       listen(listener) {\r\n         return listeners.push(listener);\r\n       },\r\n       ……\r\n     };\r\n   //返回history实例\r\n     return history;\r\n   }\r\n   \r\n   ```\r\n\r\n## `Browser Router`\r\n\r\n```react\r\n/**\r\n * browser router 提供最干净的url\r\n */\r\nexport function BrowserRouter({\r\n  basename,\r\n  children,\r\n  window\r\n}: BrowserRouterProps) {\r\n  let historyRef = React.useRef<BrowserHistory>();\r\n  if (historyRef.current == null) {\r\n  \t//1.createBrowserHistory，获取对应的history实例\r\n    historyRef.current = createBrowserHistory({ window });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = React.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  //2.useLayoutEffect，保证同步执行，也就是页面的渲染\r\n  //3.history.listen，添加事件监听\r\n  React.useLayoutEffect(() => history.listen(setState), [history]);\r\n\t\r\n  //4.Router\r\n  return (\r\n    <Router\r\n      basename={basename}\r\n      children={children}\r\n      location={state.location}\r\n      navigationType={state.action}\r\n      navigator={history}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n最后返回的`<Router`组件时来自于`React Router`中的自定义组件：\r\n\r\n```react\r\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\r\n\r\ninterface NavigationContextObject {\r\n  basename: string;\r\n  navigator: Navigator;\r\n  static: boolean;\r\n}\r\n\r\nconst NavigationContext = React.createContext<NavigationContextObject>(null!);\r\n\r\ninterface LocationContextObject {\r\n  location: Location;\r\n  navigationType: NavigationType;  // >>> history.Action\r\n}\r\n\r\nconst LocationContext = React.createContext<LocationContextObject>(null!);\r\n\r\n\r\n\r\nexport function Router({\r\n  basename: basenameProp = \"/\",\r\n  children = null,\r\n  location: locationProp,\r\n  navigationType = NavigationType.Pop,\r\n  navigator,\r\n  static: staticProp = false\r\n}: RouterProps): React.ReactElement | null {\r\n  ……\r\n\r\n  let {\r\n    pathname = \"/\",\r\n    search = \"\",\r\n    hash = \"\",\r\n    state = null,\r\n    key = \"default\"\r\n  } = locationProp;\r\n\r\n  ……\r\n\r\n  return (\r\n    <NavigationContext.Provider value={navigationContext}>\r\n      <LocationContext.Provider\r\n        children={children}\r\n        value={{ location, navigationType }}\r\n      />\r\n    </NavigationContext.Provider>\r\n  );\r\n}\r\n```\r\n\r\n其实 `<Router>` 只做了两件事：\r\n\r\n- 一是给子组件包了一层`context`，让路由信息（ history 和 location 对象）能传递给其下所有子孙组件\r\n- 二是绑定了路由监听事件，使每次路由的改变都触发`setState`。\r\n\r\n这也就是为什么`Route`需要包裹在`Router`组件中，因为路由信息都由外层的容器组件通过 `context` 的方式，传递给所有子孙组件，子孙组件在拿到当前路由信息后，才能匹配并渲染出对应内容。此外在路由发生改变的时候，容器组件`<Router>` 会通过 `setState()` 的方式，触发子组件重新渲染。\r\n\r\n## Route\r\n\r\n```react\r\nfunction Route(\r\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\r\n): React.ReactElement | null {\r\n  invariant(\r\n    false,\r\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\r\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\r\n  );\r\n}\r\n```\r\n\r\n在这里我们就可以看到其实`Route`就是单纯的信息载体，纯打工人了。","title":"React-Router"}
