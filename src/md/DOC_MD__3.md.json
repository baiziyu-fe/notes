{"content":"# 模块化标准现状\n\n## 1. CommonJS\n\n```JS\nvar num = require('./util');\nmodule.exports = {\n  num: num,\n  add: add\n}\n```\n\n- 规范\n  - 块的标识应遵循一定的书写规则。\n  - 定义全局函数 require(dependency)，通过传入模块标识来引入其他依赖模块，执行的结果即为别的模块暴漏出来的 API。\n  - 如果被 require 函数引入的模块中也包含外部依赖，则依次加载这些依赖。\n  - 如果引入模块失败，那么 require 函数应该抛出一个异常。\n  - 模块通过变量 exports 来向外暴露 API，exports 只能是一个 Object 对象，暴露的 API 须作为该对象的属性。\n\n- 优点\n  - 简单易用。\n  - 解决了模块依赖的问题。\n  - 减少了全局变量污染。\n\n- 缺点\n  - 无法在浏览器端使用。\n  - 无法非阻塞的并行加载多个模块。\n\n## 2. AMD（Async Module Definition）\n\n```JS\ndefine({\n    method1: function() {},\n    method2: function() {},\n});\n\nrequire(['foo', 'bar'], function ( foo, bar ) {\n        foo.doSomething();\n});\n```\n\n- 规范\n  - 模块的标识遵循 CommonJS Module Identifiers。\n  - 定义全局函数 define(id, dependencies, factory)，用于定义模块。dependencies 为依赖的模块数组，在 factory 中需传入形参与之一一对应。\n  - 如果 dependencies 的值中有 require、exports 或 module，则与 CommonJS 中的实现保持一致。\n  - 如果 dependencies 省略不写，则默认为 ['require', 'exports', 'module']，factory 中也会默认传入三者。\n  - 如果 factory 为函数，模块可以通过以下三种方式对外暴漏 API：return 任意类型；exports.XModule = XModule、module.exports = XModule。\n  - 如果 factory 为对象，则该对象即为模块的导出值。\n\n- 优点\n  - 可以用于浏览器。\n  - 异步加载模块。\n  - 可以并行加载多个模块。\n\n- 缺点\n  - 提高了开发成本。\n  - 不能按需加载，而是提前加载所有的依赖。\n\n## 3. CMD （Common Module Definition）\n\n```JS\ndefine(function (require, exports, module) {\n  var add = function (a, b) {\n    return a + b;\n  }\n  exports.add = add;\n});\n\nseajs.use(['math.js'], function (math) {\n  var sum = math.add(1, 2);\n});\n```\n\n- 优点\n  - 实现了浏览器端的模块化加载。\n  - 可以按需加载。\n  - 依赖就近，延迟执行。\n\n- 缺点\n  - 依赖 SPM 打包，模块加载逻辑偏重。\n\n## 4. UMD （Universal Module Definition）\n\nUMD 是一种 JavaScript 通用模块定义规范，让你的模块能在 JavaScript 所有运行环境中发挥作用。\n\n- 规定如下\n  - 优先判断是否存在 exports 方法，如果存在，则采用 CommonJS 方式加载模块；\n  - 其次判断是否存在 define 方法，如果存在，则采用 AMD 方式加载模块；\n  - 最后判断 global 对象上是否定义了所需依赖，如果存在，则直接使用；反之，则抛出异常。\n\n## 5. ES Module\n\n```JS\nexportfunction hello() { };\nexportdefault {\n  // ...\n};\n\nimport { readFile } from'fs';\nimport React from'react';\n```\n\n- 优点\n  - 语法层面的支持，使用简单。\n\n- 缺点\n  - 浏览器还没有完全兼容，必须通过工具转换成标准的 ES5 后才能正常运行。\n\n![](https://mmbiz.qpic.cn/mmbiz_jpg/xsw6Lt5pDCufQiaO49nBCxJicg5R3LIGTwV7JNiadJ4EUW8jJ6RFOJFIFNJtgP08GMrEhZ6hdZbujEf0umvrpztog/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)","title":"前端模块化"}
